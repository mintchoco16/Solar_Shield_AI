# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1INPHrbgNWMiPqVePyVO54Q0ek0xYypAE
"""

from google.colab import drive

from google.colab import drive
drive.mount('/content/drive')

drive.mount('/content/drive')

import pandas as pd

dataset=pd.read_csv('/content/drive/MyDrive/data/weather.csv')

import pandas as pd
from statsmodels.tsa.api import VAR
from sklearn.model_selection import TimeSeriesSplit
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import mean_squared_error
import numpy as np
import matplotlib.pyplot as plt


# Assuming the delimiter is a comma and there are potential quoting issues
data = pd.read_csv("/content/drive/MyDrive/data/weather.csv", index_col="DATE", sep=',', quotechar='"')

data

null_pct = data.apply(pd.isnull).sum()/data.shape[0]

null_pct

data.apply(pd.isnull).sum()

null_pct

data.columns = data.columns.str.lower()

data

data = data.ffill()

data.apply(pd.isnull).sum()

data.index

# Convert 'date' to datetime object and set it as the index
data.index = pd.to_datetime(data.index, format='%Y-%m-%d')

# Select relevant features
features = ['tmax', 'tmin', 'prcp']
data_selected = data[features]

# Standardize the features
scaler = StandardScaler()
data_scaled = scaler.fit_transform(data_selected)

# Time series cross-validation
tscv = TimeSeriesSplit(n_splits=5)
heatwave_threshold = 30  # Define your threshold for heatwave, adjust as needed

for train_index, test_index in tscv.split(data_scaled):
    train, test = data_scaled[train_index], data_scaled[test_index]

    # Fit VAR model
    model = VAR(train)
    model_fit = model.fit()

    # Forecast for user input
    input_month = int(input("Enter the month (1-12): "))
    input_date = int(input("Enter the date (1-31): "))
    if input_month not in range(1, 13):
        print("Invalid Month, Run Again.")
        break

    if input_date not in range(1, 32):
        print("Invalid Date, Run Again.")
        break



    # Find the row corresponding to the specified month and date
    test_date_indices = np.where((data.index.month == input_month) & (data.index.day == input_date))[0]

    # Check if there is any data for the specified month and date
    if len(test_date_indices) > 0:
        test_date_index = test_date_indices[0]
        input_values = test[test_date_index:test_date_index+1, :]  # Ensure the correct shape

        # Forecast multiple steps ahead
        forecast = model_fit.forecast(y=input_values, steps=1)

        # Inverse transform the forecasted values
        predicted_values = scaler.inverse_transform(forecast)

        # Check if TMAX or TMIN exceeds the heatwave threshold
        heatwave_predicted = any(predicted_values[0, :2] > heatwave_threshold)

        # Print the result
        print(f"Heatwave Predicted: {heatwave_predicted}")

        # Visualize actual vs fitted vs predicted
        x_values_actual = data.index[-len(test):]  # Include all elements

        # Plot the actual values
        plt.plot(x_values_actual, scaler.inverse_transform(test), label='Actual')

        # Plot the fitted values
        x_values_fitted = x_values_actual[:-1]  # Exclude the last element
        fitted_values = model_fit.fittedvalues[:-1]

        # Check if the dimensions match before plotting
        if len(x_values_fitted) == len(fitted_values):
            plt.plot(x_values_fitted, fitted_values[:, 0], label='Fitted TMAX', linestyle='--')
            plt.plot(x_values_fitted, fitted_values[:, 1], label='Fitted TMIN', linestyle='--')
            plt.plot(x_values_fitted, fitted_values[:, 2], label='Fitted PRCP', linestyle='--')
        else:
            # If there's a mismatch, adjust the lengths and plot
            min_len = min(len(x_values_fitted), len(fitted_values))
            plt.plot(x_values_fitted[:min_len], fitted_values[:min_len, 0], label='Fitted TMAX', linestyle='--')
            plt.plot(x_values_fitted[:min_len], fitted_values[:min_len, 1], label='Fitted TMIN', linestyle='--')
            plt.plot(x_values_fitted[:min_len], fitted_values[:min_len, 2], label='Fitted PRCP', linestyle='--')

        # Plot the predicted values
        x_values_predicted = [x_values_actual[-1] + pd.Timedelta(days=1)]  # Use a list to ensure the correct dimension
        #plt.plot(x_values_predicted, predicted_values.flatten(), marker='o', label='Predicted')

        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Scaled Feature Values')
        plt.title('Actual vs Fitted vs Predicted')
        plt.show()
        break

    else:
        print(f"No data found for the specified month ({input_month}) and date ({input_date}).")
        break

# Convert 'date' to datetime object and set it as the index
data.index = pd.to_datetime(data.index, format='%Y-%m-%d')

# Select relevant features
features = ['tmax', 'tmin', 'prcp']
data_selected = data[features]

# Standardize the features
scaler = StandardScaler()
data_scaled = scaler.fit_transform(data_selected)

# Time series cross-validation
tscv = TimeSeriesSplit(n_splits=5)
heatwave_threshold = 30  # Define your threshold for heatwave, adjust as needed

for train_index, test_index in tscv.split(data_scaled):
    train, test = data_scaled[train_index], data_scaled[test_index]

    # Fit VAR model
    model = VAR(train)
    model_fit = model.fit()

    # Forecast for user input
    input_month = int(input("Enter the month (1-12): "))
    input_date = int(input("Enter the date (1-31): "))
    if input_month not in range(1, 13):
        print("Invalid Month, Run Again.")
        break

    if input_date not in range(1, 32):
        print("Invalid Date, Run Again.")
        break



    # Find the row corresponding to the specified month and date
    test_date_indices = np.where((data.index.month == input_month) & (data.index.day == input_date))[0]

    # Check if there is any data for the specified month and date
    if len(test_date_indices) > 0:
        test_date_index = test_date_indices[0]
        input_values = test[test_date_index:test_date_index+1, :]  # Ensure the correct shape

        # Forecast multiple steps ahead
        forecast = model_fit.forecast(y=input_values, steps=1)

        # Inverse transform the forecasted values
        predicted_values = scaler.inverse_transform(forecast)

        # Check if TMAX or TMIN exceeds the heatwave threshold
        heatwave_predicted = any(predicted_values[0, :2] > heatwave_threshold)

        # Print the result
        print(f"Heatwave Predicted: {heatwave_predicted}")

        # Visualize actual vs fitted vs predicted
        x_values_actual = data.index[-len(test):]  # Include all elements

        # Plot the actual values
        plt.plot(x_values_actual, scaler.inverse_transform(test), label='Actual')

        # Plot the fitted values
        x_values_fitted = x_values_actual[:-1]  # Exclude the last element
        fitted_values = model_fit.fittedvalues[:-1]

        # Check if the dimensions match before plotting
        if len(x_values_fitted) == len(fitted_values):
            plt.plot(x_values_fitted, fitted_values[:, 0], label='Fitted TMAX', linestyle='--')
            plt.plot(x_values_fitted, fitted_values[:, 1], label='Fitted TMIN', linestyle='--')
            plt.plot(x_values_fitted, fitted_values[:, 2], label='Fitted PRCP', linestyle='--')
        else:
            # If there's a mismatch, adjust the lengths and plot
            min_len = min(len(x_values_fitted), len(fitted_values))
            plt.plot(x_values_fitted[:min_len], fitted_values[:min_len, 0], label='Fitted TMAX', linestyle='--')
            plt.plot(x_values_fitted[:min_len], fitted_values[:min_len, 1], label='Fitted TMIN', linestyle='--')
            plt.plot(x_values_fitted[:min_len], fitted_values[:min_len, 2], label='Fitted PRCP', linestyle='--')

        # Plot the predicted values
        x_values_predicted = [x_values_actual[-1] + pd.Timedelta(days=1)]  # Use a list to ensure the correct dimension
        #plt.plot(x_values_predicted, predicted_values.flatten(), marker='o', label='Predicted')

        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Scaled Feature Values')
        plt.title('Actual vs Fitted vs Predicted')
        plt.show()
        break

    else:
        print(f"No data found for the specified month ({input_month}) and date ({input_date}).")
        break

# Convert 'date' to datetime object and set it as the index
data.index = pd.to_datetime(data.index, format='%Y-%m-%d')

# Select relevant features
features = ['tmax', 'tmin', 'prcp']
data_selected = data[features]

# Standardize the features
scaler = StandardScaler()
data_scaled = scaler.fit_transform(data_selected)

# Time series cross-validation
tscv = TimeSeriesSplit(n_splits=5)
heatwave_threshold = 30  # Define your threshold for heatwave, adjust as needed

for train_index, test_index in tscv.split(data_scaled):
    train, test = data_scaled[train_index], data_scaled[test_index]

    # Fit VAR model
    model = VAR(train)
    model_fit = model.fit()

    # Forecast for user input
    input_month = int(input("Enter the month (1-12): "))
    input_date = int(input("Enter the date (1-31): "))
    if input_month not in range(1, 13):
        print("Invalid Month, Run Again.")
        break

    if input_date not in range(1, 32):
        print("Invalid Date, Run Again.")
        break



    # Find the row corresponding to the specified month and date
    test_date_indices = np.where((data.index.month == input_month) & (data.index.day == input_date))[0]

    # Check if there is any data for the specified month and date
    if len(test_date_indices) > 0:
        test_date_index = test_date_indices[0]
        input_values = test[test_date_index:test_date_index+1, :]  # Ensure the correct shape

        # Forecast multiple steps ahead
        forecast = model_fit.forecast(y=input_values, steps=1)

        # Inverse transform the forecasted values
        predicted_values = scaler.inverse_transform(forecast)

        # Check if TMAX or TMIN exceeds the heatwave threshold
        heatwave_predicted = any(predicted_values[0, :2] > heatwave_threshold)

        # Print the result
        print(f"Heatwave Predicted: {heatwave_predicted}")

        # Visualize actual vs fitted vs predicted
        x_values_actual = data.index[-len(test):]  # Include all elements

        # Plot the actual values
        plt.plot(x_values_actual, scaler.inverse_transform(test), label='Actual')

        # Plot the fitted values
        x_values_fitted = x_values_actual[:-1]  # Exclude the last element
        fitted_values = model_fit.fittedvalues[:-1]

        # Check if the dimensions match before plotting
        if len(x_values_fitted) == len(fitted_values):
            plt.plot(x_values_fitted, fitted_values[:, 0], label='Fitted TMAX', linestyle='--')
            plt.plot(x_values_fitted, fitted_values[:, 1], label='Fitted TMIN', linestyle='--')
            plt.plot(x_values_fitted, fitted_values[:, 2], label='Fitted PRCP', linestyle='--')
        else:
            # If there's a mismatch, adjust the lengths and plot
            min_len = min(len(x_values_fitted), len(fitted_values))
            plt.plot(x_values_fitted[:min_len], fitted_values[:min_len, 0], label='Fitted TMAX', linestyle='--')
            plt.plot(x_values_fitted[:min_len], fitted_values[:min_len, 1], label='Fitted TMIN', linestyle='--')
            plt.plot(x_values_fitted[:min_len], fitted_values[:min_len, 2], label='Fitted PRCP', linestyle='--')

        # Plot the predicted values
        x_values_predicted = [x_values_actual[-1] + pd.Timedelta(days=1)]  # Use a list to ensure the correct dimension
        #plt.plot(x_values_predicted, predicted_values.flatten(), marker='o', label='Predicted')

        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Scaled Feature Values')
        plt.title('Actual vs Fitted vs Predicted')
        plt.show()
        break

    else:
        print(f"No data found for the specified month ({input_month}) and date ({input_date}).")
        break

# Convert 'date' to datetime object and set it as the index
data.index = pd.to_datetime(data.index, format='%Y-%m-%d')

# Select relevant features
features = ['tmax', 'tmin', 'prcp']
data_selected = data[features]

# Standardize the features
scaler = StandardScaler()
data_scaled = scaler.fit_transform(data_selected)

# Time series cross-validation
tscv = TimeSeriesSplit(n_splits=5)
heatwave_threshold = 30  # Define your threshold for heatwave, adjust as needed

for train_index, test_index in tscv.split(data_scaled):
    train, test = data_scaled[train_index], data_scaled[test_index]

    # Fit VAR model
    model = VAR(train)
    model_fit = model.fit()

    # Forecast for user input
    input_month = int(input("Enter the month (1-12): "))
    input_date = int(input("Enter the date (1-31): "))
    if input_month not in range(1, 13):
        print("Invalid Month, Run Again.")
        break

    if input_date not in range(1, 32):
        print("Invalid Date, Run Again.")
        break



    # Find the row corresponding to the specified month and date
    test_date_indices = np.where((data.index.month == input_month) & (data.index.day == input_date))[0]

    # Check if there is any data for the specified month and date
    if len(test_date_indices) > 0:
        test_date_index = test_date_indices[0]
        input_values = test[test_date_index:test_date_index+1, :]  # Ensure the correct shape

        # Forecast multiple steps ahead
        forecast = model_fit.forecast(y=input_values, steps=1)

        # Inverse transform the forecasted values
        predicted_values = scaler.inverse_transform(forecast)

        # Check if TMAX or TMIN exceeds the heatwave threshold
        heatwave_predicted = any(predicted_values[0, :2] > heatwave_threshold)

        # Print the result
        print(f"Heatwave Predicted: {heatwave_predicted}")

        # Visualize actual vs fitted vs predicted
        x_values_actual = data.index[-len(test):]  # Include all elements

        # Plot the actual values
        plt.plot(x_values_actual, scaler.inverse_transform(test), label='Actual')

        # Plot the fitted values
        x_values_fitted = x_values_actual[:-1]  # Exclude the last element
        fitted_values = model_fit.fittedvalues[:-1]

        # Check if the dimensions match before plotting
        if len(x_values_fitted) == len(fitted_values):
            plt.plot(x_values_fitted, fitted_values[:, 0], label='Fitted TMAX', linestyle='--')
            plt.plot(x_values_fitted, fitted_values[:, 1], label='Fitted TMIN', linestyle='--')
            plt.plot(x_values_fitted, fitted_values[:, 2], label='Fitted PRCP', linestyle='--')
        else:
            # If there's a mismatch, adjust the lengths and plot
            min_len = min(len(x_values_fitted), len(fitted_values))
            plt.plot(x_values_fitted[:min_len], fitted_values[:min_len, 0], label='Fitted TMAX', linestyle='--')
            plt.plot(x_values_fitted[:min_len], fitted_values[:min_len, 1], label='Fitted TMIN', linestyle='--')
            plt.plot(x_values_fitted[:min_len], fitted_values[:min_len, 2], label='Fitted PRCP', linestyle='--')

        # Plot the predicted values
        x_values_predicted = [x_values_actual[-1] + pd.Timedelta(days=1)]  # Use a list to ensure the correct dimension
        #plt.plot(x_values_predicted, predicted_values.flatten(), marker='o', label='Predicted')

        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Scaled Feature Values')
        plt.title('Actual vs Fitted vs Predicted')
        plt.show()
        break

    else:
        print(f"No data found for the specified month ({input_month}) and date ({input_date}).")
        break

# Convert 'date' to datetime object and set it as the index
data.index = pd.to_datetime(data.index, format='%Y-%m-%d')

# Select relevant features
features = ['tmax', 'tmin', 'prcp']
data_selected = data[features]

# Standardize the features
scaler = StandardScaler()
data_scaled = scaler.fit_transform(data_selected)

# Time series cross-validation
tscv = TimeSeriesSplit(n_splits=5)
heatwave_threshold = 30  # Define your threshold for heatwave, adjust as needed

for train_index, test_index in tscv.split(data_scaled):
    train, test = data_scaled[train_index], data_scaled[test_index]

    # Fit VAR model
    model = VAR(train)
    model_fit = model.fit()

    # Forecast for user input
    input_month = int(input("Enter the month (1-12): "))
    input_date = int(input("Enter the date (1-31): "))
    if input_month not in range(1, 13):
        print("Invalid Month, Run Again.")
        break

    if input_date not in range(1, 32):
        print("Invalid Date, Run Again.")
        break



    # Find the row corresponding to the specified month and date
    test_date_indices = np.where((data.index.month == input_month) & (data.index.day == input_date))[0]

    # Check if there is any data for the specified month and date
    if len(test_date_indices) > 0:
        test_date_index = test_date_indices[0]
        input_values = test[test_date_index:test_date_index+1, :]  # Ensure the correct shape

        # Forecast multiple steps ahead
        forecast = model_fit.forecast(y=input_values, steps=1)

        # Inverse transform the forecasted values
        predicted_values = scaler.inverse_transform(forecast)

        # Check if TMAX or TMIN exceeds the heatwave threshold
        heatwave_predicted = any(predicted_values[0, :2] > heatwave_threshold)

        # Print the result
        print(f"Heatwave Predicted: {heatwave_predicted}")

        # Visualize actual vs fitted vs predicted
        x_values_actual = data.index[-len(test):]  # Include all elements

        # Plot the actual values
        plt.plot(x_values_actual, scaler.inverse_transform(test), label='Actual')

        # Plot the fitted values
        x_values_fitted = x_values_actual[:-1]  # Exclude the last element
        fitted_values = model_fit.fittedvalues[:-1]

        # Check if the dimensions match before plotting
        if len(x_values_fitted) == len(fitted_values):
            plt.plot(x_values_fitted, fitted_values[:, 0], label='Fitted TMAX', linestyle='--')
            plt.plot(x_values_fitted, fitted_values[:, 1], label='Fitted TMIN', linestyle='--')
            plt.plot(x_values_fitted, fitted_values[:, 2], label='Fitted PRCP', linestyle='--')
        else:
            # If there's a mismatch, adjust the lengths and plot
            min_len = min(len(x_values_fitted), len(fitted_values))
            plt.plot(x_values_fitted[:min_len], fitted_values[:min_len, 0], label='Fitted TMAX', linestyle='--')
            plt.plot(x_values_fitted[:min_len], fitted_values[:min_len, 1], label='Fitted TMIN', linestyle='--')
            plt.plot(x_values_fitted[:min_len], fitted_values[:min_len, 2], label='Fitted PRCP', linestyle='--')

        # Plot the predicted values
        x_values_predicted = [x_values_actual[-1] + pd.Timedelta(days=1)]  # Use a list to ensure the correct dimension
        #plt.plot(x_values_predicted, predicted_values.flatten(), marker='o', label='Predicted')

        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Scaled Feature Values')
        plt.title('Actual vs Fitted vs Predicted')
        plt.show()
        break

    else:
        print(f"No data found for the specified month ({input_month}) and date ({input_date}).")
        break
